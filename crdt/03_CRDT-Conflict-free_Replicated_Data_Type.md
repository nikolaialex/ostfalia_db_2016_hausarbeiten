# 3. CRDT - Conflict-free Replicated Data Type
In der englischen Version von Wikipedia heißt es:
> „CRDTs are used to replicate data across multiple computers in a network, executing updates without the need for remote synchronization. This would lead to merge conflicts in systems using conventional eventual consistency technology, but CRDTs are designed such that conflicts are mathematically impossible.” (Wikipedia 2016)

Es geht also in diesem kurzen Zitat, welches aus den Wikipedia-Ausführungen zum Thema CRDT herausgelöst wurde, recht treffend um die Umschreibung der Abkürzung – um die Replikation von Daten in einem verteilten System unter Vermeidung von Konflikten. Das reicht aber noch nicht.
> „Replicating data under Eventual Consistency (EC) allows any replica to accept updates without remote synchronisation. This ensures performance and scalability in large-scale distributed systems (e.g., clouds). [...] Under a formal Strong Eventual Consistency (SEC) model, we study sufficient conditions for convergence. A data type that satisfies these conditions is called a Conflict-free Replicated Data Type (CRDT).” (Shapiro et al. 2011b, S. 386)

Hierbei wird noch darauf verwiesen, dass zur Synchronisation der Repliken keine separate (Remote-)Lösung benötigt wird. Es findet vielmehr quasi keine Synchronisation im engeren Sinne statt, sondern die Verbreitung von Veränderungen der Repliken verläuft asynchron und völlig eigenständig. Außerdem müssen noch weitere Bedingungen erfüllt sein. Im diesem Zusammenhang stößt man in dem Zitat auf Begriffe wie „eventual consistency“ oder „strong eventual consistency“. In der Literatur wird zum Thema CRDT auch  immer wieder „optimistic replication“ erwähnt. Aus diesem Grund und um die Abkürzung CRDT noch einmal näher zu betrachten, sollen im folgenden Abschnitt erst einmal einige Begrifflichkeiten erläutert werden.
## 3.1. Begrifflichkeiten
### 3.1.1. CRDT
Die Abkürzung „CRDT“ bedeutet ausgeschrieben „conflict-free replicated data type“ oder zu Deutsch „Konfliktfrei Replizierter Daten-Typ“. Zumindest wird dies nach herrschender Meinung so gesehen. Allerdings findet man auch andere Interpretationen. So ist in dem Artikel von (Weilbach et al. 2015) im 1. Kapitel („Introduction“) von „convergent replicated datatypes (CRDTs)“ mit Angabe der entsprechenden Abkürzung (CRDT) die Rede, während unter Zusatz der gleichen Abkürzung im 2. Kapitel (“Related Work”) „confluent replicated data types (CRDTs)” angegeben wird (vgl. Weilbach et al. 2015). Während sich erstere Verwendung auf einen häufiger gebräuchlichen Typ von CRTDs bezieht und im Anschluss noch betrachtet wird, ist die letztere Verwendung in dieser Form seltener zu finden.
Wie eben angedeutet, ist bezüglich der Abkürzung „CRDT“ weiterhin darauf zu achten, dass es nicht zu Verwechslungen mit einem der beiden konfliktfreien Typen kommt. In Wikipedia ist in diesem Zusammenhang auch von Klassen die Rede. Hier heißt es:
> „Two general classes of CRDTs are known to exist. Although any CRDT of one class has an other-class equivalent, the classes differ in assumptions and performance characteristics.” (Wikipedia 2016)

An wieder anderer Stelle wird von „Stilen“ bzw. „styles“ gesprochen (vgl. Shapiro et al. 2011a, S. 5)  Diese Typen, Klassen oder eben auch Stile verfolgen zwar unterschiedliche Ansätze im Umgang mir den Repliken, werden aber in der Literatur bzw. in Abhandlungen im Internet zuweilen ebenfalls nur mit CRDT angegeben. Es handelt sich dabei zum einen wie bereits erwähnt um „convergent replicated data types“ und zum anderen um „commutative replicated data types“. Dabei werden „convergent replicated data types“ präzisierend mit „CvRDT“ und „commutative replicated data types“ mit „CmRDT“ abgekürzt. Diese beiden unterschiedlichen Ansätze werden in den nächsten Abschnitten näher erläutert.
Aufgrund dieser Ungereimtheiten erscheint es jedoch sinnvoll oder gar notwendig, eine entsprechende Festlegung bezüglich der Verwendung der Abkürzungen zu treffen. In der vorliegenden Arbeit werden sie also wie folgt verwendet:
-	CRDT - conflict-free replicated data type
-	CvRDT - convergent replicated data type
-	CmRDT - commutative replicated data type

### 3.1.2. Optimistic Replication
Bezüglich des Begriffs „optimistic replication“ wird der gleichnamige Zeitschriftenaufsatz von Saito und Shapiro aus dem Jahr 2005 herangezogen. Darin ist die optimistische Replikation folgendermaßen definiert:
> „Optimistic replication is a group of techniques for sharing data efficiently in wide-area or mobile environments. The key feature that separates optimistic replication algorithms from their pessimistic counterparts is their approach to concurrency control. Pessimistic algorithms synchronously coordinate replicas during accesses and block other users during an update. Optimistic algorithms let data be accessed without a priori synchronization based on the “optimistic” assumption that problems will occur only rarely, if at all. Updates are propagated in the background, and occasional conflicts are fixed after they happen. It is not a new idea, but its use has expanded as the Internet and mobile computing technologies have become more widespread.“ (Saito und Shapiro 2005, S. 43–44)

Damit ist klar, dass dieser Ansatz grundlegend für die Abarbeitung ohne externes Synchronisierungssystem herangezogen wurde. Allerdings ist insofern eine Modifizierung erkennbar, da bei CRDTs gar kein Auftreten von Konflikten erst zugelassen wird und somit eine nachträgliche Behandlung derselben überflüssig wird.
### 3.1.3. Eventual Consistency
> „Informally, eventual consistency means that replicas eventually reach the same value if clients stop submitting updates. Eventually consistent systems accept local updates without remote synchronization, improving performance and scalability by sacrificing strong consistency. Without remote synchronization, replicas concurrently hold different values which are expected to converge over time.“ (Wikipedia 2016)

In Wikipedia wird in diesem Zusammenhang noch auf die Problematik der Entstehung und Behandlung von Konflikten eingegangen. Auch (Shapiro et al. 2011b) thematisieren diese Probleme.
> „Several EC systems will execute an update immediately, only to discover later that it conflicts with another, and to roll back to resolve this conflict [...]. This constitutes a waste of resources, and in general requires a consensus to ensure that all replicas arbitrate conflicts in the same way. To avoid this, we require a stronger condition“ (Shapiro et al. 2011b, S. 389)

Sie verweisen in diesem Zusammenhang auf die Strong Eventual Consistency, um die Komplexität einer Konfliktlösung oder auch eines roll back zu vermeiden.
### 3.1.4. Strong Eventual Consistency
Die Starke Konsistenz nach Vogels,
> „Strong consistency. After the update completes, any subsequent access (by A, B, or C) will return the updated value.“ (Vogels 2008, S. 17),

wird bei (Shapiro et al. 2011b) unter Berücksichtigung des Vermeidens von Konflikten um die starke Konvergenz zur „Strong Eventual Consistency“ erweitert.
##3.2.	Convergent Replicated Data Type (CvRDT)
Bei dem Convergent Replicated Data Type handelt es sich um einen so genannten „state-based“ CRDT. Er ist also „statusbasiert“. Dabei wird durch das Ausführen eines Updates lediglich der Status genau einer Replik verändert, also quasi lokal basierend auf die Lokalität, an welcher sich die Replik befindet, auf die zugegriffen wurde. Der Ansatz verfolgt anschließend das Ziel, dass die veränderte Replik in zufälliger Weise ihren kompletten neuen Status an eine andere, willkürlich ausgewählte Replik sendet. Diese führt den erhaltenen Status mit ihrem eigenen zusammen (merge) und sendet den zusammengeführten Status ihrerseits willkürlich an eine weitere Replik. Dieser Vorgang setzt sich solange fort, bis alle Repliken quasi alle Zustände direkt oder auch indirekt erhalten und zusammengeführt und somit alle einen einheitlichen Status erreicht haben. Damit ist dann ein konsistenter Zustand im Gesamtsystem erreicht. Dies ist in der folgenden  Abbildung 2 schematisch dargestellt. Wichtig ist dabei, dass die veränderte Replik die Statusänderung nicht nur einmal sendet, sondern mehrmals (quasi unendlich oft), bis der Endzustand überall erreicht ist.

![State-Based Replication (Shapiro et al. 2011a, S. 6)](https://github.com/achatzSWT/ostfalia_db_2016_hausarbeiten/blob/master/crdt/Bilder/state-based-replication.JPG)

**Abbildung 2: State-Based Replication (Shapiro et al. 2011a, S. 6)**

Durch das permanente Senden wird zwar erreicht, dass jede Replik in den Besitz der Updates bzw. Änderungen kommt, aber um sich Convergent Replicated Data Type nennen zu können, bedarf es wie bereits erwähnt weiterer Bedingungen. Diese sind mathematischer Natur, und sorgen dafür, dass Konflikte vermieden werden und der Datenbestand letztlich eine Konsistenz erreicht. So ist es von größter Wichtigkeit, dass die Merge-Funktion assoziativ, kommutativ und idempotent ist. Das bedeutet, dass es für das Ergebnis egal sein muss, wie oft Updates eintreffen, in welcher Reihenfolge sie eintreffen und in welcher Reihenfolge die nötigen Operationen ausgeführt werden. Das Ergebnis des Zusammenführungsvorgangs muss immer das gleiche sein.
Daraus ergeben sich einige Vor- und Nachteile. Einerseits ergeben sich aus den beschriebenen Eigenschaften recht schwache Messaging-Anforderungen. So wie die Infrastruktur zur Verfügung steht, können permanent Statusabgleiche durchgeführt und die Konsistenz hoch gehalten werden. Andererseits sind die Anforderungen an die Infrastruktur insofern hoch, das jedes Mal der gesamte Staus der jeweiligen Replik übertragen werden muss, was bei großen Inhalten zu erhöhter Netzlast führt.
##3.3.	Commutative Replicated Data Type (CmRDT)
Der Commutative Replicated Data Type ist im Gegensatz zum Convergent Replicated Data Type „operation-based“, also ein operationsbasierter Typ. Bei diesem Ansatz wird darauf verzichtet, den gesamten Status einer Replik an andere Repliken zu übertragen. Hierbei geht es nur um die Übertragung der die Änderung hervorrufenden Operation, welche dann den Zustand bzw. Status bei der empfangenden Replik lokal verändert. Dafür wird die Übertragung jedoch als Broadcast, also an alle Repliken gleichzeitig, gesendet und nicht nur jeweils an eine willkürlich ausgewählte, wie dies beim CvRDT der Fall ist. Die Broadcastübertragung ist in der Abbildung 3 grafisch dargestellt.

![Operation-Based Replication (Shapiro et al. 2011a, S. 8)](https://github.com/achatzSWT/ostfalia_db_2016_hausarbeiten/blob/master/crdt/Bilder/operation-based-replication.JPG)

**Abbildung 3: Operation-Based Replication (Shapiro et al. 2011a, S. 8)**

Dies ist insofern sinnvoll und auch nötig, da es hierbei keine Zusammenführungs-Funktion (merge) gibt, sondern jede Operation basierend auf dem Ausgangszustand lokal bei jeder Replik durchgeführt wird. Dazu kommt, dass die Operationen zwar kommutativ sind, also bei gleichzeitigem Eintreffen in beliebiger Folge angewandt werden können, jedoch keine Idempotenz vorhanden ist. Damit würden mehrfach gelieferte Daten zu Verfälschungen des Zustandes führen, womit eine eindeutige Kenntnis über den Kausalverlauf der Lieferungen bzw. der Updates unerlässlich ist.
Folglich ist in Bezug auf den Commutative Replicated Data Type im Gegensatz zum Convergent Replicated Data Type eine zuverlässige Übertragung nötig, was sich in zusätzlichen Garantien bezüglich des Netzwerkprotokolls niederschlägt. (vgl. Wikipedia 2016) Vorteilhaft wirkt sich die Begrenzung der Lieferungen auf die Zustandsänderungen natürlich auf der Netzwerkverkehr aus, der insbesondere bei größeren Statusinhalten der Repliken trotz Broadcastservice auf einen Bruchteil dessen sinkt, was mit einem Convergent Replicated Data Type nötig wäre.
